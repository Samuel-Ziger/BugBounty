#!/usr/bin/env python3
"""
Módulo de Escaneamento de Portas
Escaneia portas abertas nos dispositivos alvo
"""

import socket
import concurrent.futures
import logging
from typing import List, Dict, Optional
from dataclasses import dataclass
import time

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


@dataclass
class OpenPort:
    """Representa uma porta aberta"""
    port: int
    state: str  # 'open', 'filtered', 'closed'
    service: Optional[str] = None
    banner: Optional[str] = None


@dataclass
class ScanResult:
    """Resultado do escaneamento de um host"""
    ip: str
    open_ports: List[OpenPort]
    scan_time: float
    success: bool
    error: Optional[str] = None


class PortScanner:
    """Classe para escanear portas em hosts"""
    
    # Portas comuns para escanear
    COMMON_PORTS = [
        21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995,
        1723, 3306, 3389, 5900, 8080, 8443, 8888, 9000
    ]
    
    # Portas completas (1-65535) - usar com cuidado
    ALL_PORTS = list(range(1, 65536))
    
    def __init__(self, timeout: float = 1.0, max_workers: int = 50):
        """
        Inicializa o scanner de portas
        
        Args:
            timeout: Timeout para conexão (segundos)
            max_workers: Número máximo de threads
        """
        self.timeout = timeout
        self.max_workers = max_workers
        
    def scan_port(self, ip: str, port: int) -> Optional[OpenPort]:
        """
        Escaneia uma porta específica
        
        Args:
            ip: Endereço IP do host
            port: Número da porta
            
        Returns:
            OpenPort se a porta estiver aberta, None caso contrário
        """
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result = sock.connect_ex((ip, port))
            sock.close()
            
            if result == 0:
                # Porta está aberta, tenta obter banner
                service = self._identify_service(port)
                banner = self._grab_banner(ip, port)
                
                return OpenPort(
                    port=port,
                    state='open',
                    service=service,
                    banner=banner
                )
            else:
                return None
                
        except socket.timeout:
            return None
        except socket.error as e:
            logger.debug(f"Erro ao escanear {ip}:{port} - {e}")
            return None
        except Exception as e:
            logger.debug(f"Erro inesperado ao escanear {ip}:{port} - {e}")
            return None
    
    def _identify_service(self, port: int) -> Optional[str]:
        """
        Identifica o serviço baseado na porta
        
        Args:
            port: Número da porta
            
        Returns:
            Nome do serviço ou None
        """
        services = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS',
            80: 'HTTP', 110: 'POP3', 111: 'RPC', 135: 'MSRPC', 139: 'NetBIOS',
            143: 'IMAP', 443: 'HTTPS', 445: 'SMB', 993: 'IMAPS', 995: 'POP3S',
            1723: 'PPTP', 3306: 'MySQL', 3389: 'RDP', 5900: 'VNC',
            8080: 'HTTP-Proxy', 8443: 'HTTPS-Alt', 8888: 'HTTP-Alt', 9000: 'SonarQube'
        }
        return services.get(port)
    
    def _grab_banner(self, ip: str, port: int) -> Optional[str]:
        """
        Tenta obter o banner do serviço
        
        Args:
            ip: Endereço IP
            port: Número da porta
            
        Returns:
            Banner do serviço ou None
        """
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2.0)
            sock.connect((ip, port))
            
            # Tenta receber dados
            sock.settimeout(1.0)
            try:
                banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                if banner:
                    return banner[:200]  # Limita tamanho
            except:
                pass
            
            sock.close()
            return None
            
        except:
            return None
    
    def scan_host(self, ip: str, ports: List[int] = None) -> ScanResult:
        """
        Escaneia um host completo
        
        Args:
            ip: Endereço IP do host
            ports: Lista de portas para escanear (padrão: portas comuns)
            
        Returns:
            ScanResult com os resultados
        """
        if ports is None:
            ports = self.COMMON_PORTS
        
        logger.info(f"Iniciando escaneamento de portas em {ip} ({len(ports)} portas)...")
        start_time = time.time()
        open_ports = []
        
        try:
            # Verifica se o host está online primeiro
            if not self._is_host_alive(ip):
                logger.warning(f"Host {ip} parece estar offline")
                return ScanResult(
                    ip=ip,
                    open_ports=[],
                    scan_time=0,
                    success=False,
                    error="Host offline"
                )
            
            # Escaneia portas em paralelo
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                future_to_port = {
                    executor.submit(self.scan_port, ip, port): port 
                    for port in ports
                }
                
                for future in concurrent.futures.as_completed(future_to_port):
                    port = future_to_port[future]
                    try:
                        result = future.result()
                        if result:
                            open_ports.append(result)
                            logger.info(f"{ip}:{result.port} [{result.service or 'Unknown'}] - OPEN")
                    except Exception as e:
                        logger.debug(f"Erro ao processar porta {port}: {e}")
            
            scan_time = time.time() - start_time
            
            logger.info(f"Escaneamento de {ip} concluído: {len(open_ports)} portas abertas em {scan_time:.2f}s")
            
            return ScanResult(
                ip=ip,
                open_ports=sorted(open_ports, key=lambda x: x.port),
                scan_time=scan_time,
                success=True
            )
            
        except Exception as e:
            logger.error(f"Erro ao escanear {ip}: {e}")
            return ScanResult(
                ip=ip,
                open_ports=[],
                scan_time=time.time() - start_time,
                success=False,
                error=str(e)
            )
    
    def _is_host_alive(self, ip: str) -> bool:
        """
        Verifica se o host está online (ping básico via socket)
        
        Args:
            ip: Endereço IP
            
        Returns:
            True se o host está online
        """
        try:
            # Tenta conectar em uma porta comum (80 ou 22)
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(0.5)
            result = sock.connect_ex((ip, 80))
            sock.close()
            return True  # Mesmo que fechada, se não deu erro de conexão, host está online
        except:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(0.5)
                result = sock.connect_ex((ip, 22))
                sock.close()
                return True
            except:
                return False
    
    def detect_false_positive(self, scan_result: ScanResult) -> bool:
        """
        Detecta possíveis falsos positivos
        
        Args:
            scan_result: Resultado do escaneamento
            
        Returns:
            True se parece ser falso positivo
        """
        # Se muitas portas abertas sem banners, pode ser falso positivo
        if len(scan_result.open_ports) > 50:
            ports_without_banner = sum(1 for p in scan_result.open_ports if not p.banner)
            if ports_without_banner > len(scan_result.open_ports) * 0.8:
                logger.warning(f"Possível falso positivo detectado em {scan_result.ip}: muitas portas sem banners")
                return True
        
        # Se todas as portas comuns estão abertas, suspeito
        if len(scan_result.open_ports) > 20:
            common_open = sum(1 for p in scan_result.open_ports if p.port in self.COMMON_PORTS)
            if common_open == len(self.COMMON_PORTS):
                logger.warning(f"Possível falso positivo detectado em {scan_result.ip}: todas portas comuns abertas")
                return True
        
        return False


if __name__ == "__main__":
    # Teste
    scanner = PortScanner()
    result = scanner.scan_host("127.0.0.1", [22, 80, 443, 8080])
    print(f"\n=== Resultado do Escaneamento ===")
    print(f"IP: {result.ip}")
    print(f"Portas abertas: {len(result.open_ports)}")
    print(f"Tempo: {result.scan_time:.2f}s")
    for port in result.open_ports:
        print(f"  {port.port} [{port.service or 'Unknown'}] - {port.banner or 'No banner'}")


